<!-- ERP -->

# totallook客户端
## 上门服务(超过多少公里不给下单)，高德地图 分享 微信支付 支付宝支付 扫码支付   







# 遇到问题 


## 0.1+0.2 != 0.3
### 原因 在计算机中遵循了IEEE 754标准，同时计算机是通过二进制的方式存储数据的，所以JavaScript 在实现 Number类型时也遵循了这个标准，js在计算时是使用二进制的方式去计算，由于二进制的转是有一定的范围的，当js的数值从十进制转二进制时，超过有效范围时会进行截取为特殊值(64位)，进行计算，此时误差就产生了   0.1 的二进制无限循环  0.2 的二进制无限循环   0.3 的二进制无限循环

### 处理
#### 原数值乘以一个任意整数，后面除于该任意整数  结果=(原数*整数 +整数 *整数)/整数   整数一般是10   100    
```
(0.1*100+0.2*100)/100 = 0.3
```
#### 四舍五入 toFixed 结果指定的小数位数  在某些情况精度有依然存在
```
(0.1+0.2).toFixed(2)
```
#### 四舍五入 Math.round() 结果最接近的整数  在某些情况精度有依然存在
```
Math.round((0.1+0.3) * 10) / 10
```

#### 借助第三方库      decimal.js    big.js

#### 总结 其实精度问题在其他语言也存在此问题，比如java c python 都有单双精度问题，遵循了IEEE754协议标准，主要制定了两个浮点数标准，单精度（float）和双精度（double）


## 微信小程序 登录 由于这里是网络请求，可能会在 Page.onLoad 之后才返回
